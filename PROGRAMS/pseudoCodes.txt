POLYNOMIAL ADDITION

STRUCT term
    DECLARE exp, coeff: integers
END STRUCT

STRUCT poly
    DECLARE n: integer
    DECLARE arr[500]: array of term
END STRUCT

FUNCTION main()
    DECLARE p1, p2, p3: poly
    SET p3.n = 0

    PRINT "ENTER THE NUMBER OF TERMS IN P1: "
    READ p1.n

    FOR i = 0 TO p1.n - 1
        PRINT "ENTER THE COEFF AS WELL AS EXP: "
        READ p1.arr[i].coeff, p1.arr[i].exp
    END FOR

    PRINT "ENTER THE NUMBER OF TERMS IN P2: "
    READ p2.n

    FOR i = 0 TO p2.n - 1
        PRINT "ENTER THE COEFF AS WELL AS EXP: "
        READ p2.arr[i].coeff, p2.arr[i].exp
    END FOR

    PRINT "FIRST: "
    FOR i = 0 TO p1.n - 1
        PRINT p1.arr[i].coeff, "x^", p1.arr[i].exp
        IF i == p1.n - 1
            PRINT " "
        ELSE
            PRINT " + "
        END IF
    END FOR

    PRINT "SECOND: "
    FOR i = 0 TO p2.n - 1
        PRINT p2.arr[i].coeff, "x^", p2.arr[i].exp
        IF i == p2.n - 1
            PRINT " "
        ELSE
            PRINT " + "
        END IF
    END FOR

    DECLARE i, j, k: integers
    SET i = 0
    SET j = 0
    SET k = 0

    WHILE i < p1.n AND j < p2.n
        IF p1.arr[i].exp == p2.arr[j].exp
            SET p3.arr[k].exp = p1.arr[i].exp
            SET p3.arr[k].coeff = p1.arr[i].coeff + p2.arr[j].coeff
            INCREMENT i
            INCREMENT j
        ELSE IF p1.arr[i].exp < p2.arr[j].exp
            SET p3.arr[k].exp = p1.arr[i].exp
            SET p3.arr[k].coeff = p1.arr[i].coeff
            INCREMENT i
        ELSE
            SET p3.arr[k].exp = p2.arr[j].exp
            SET p3.arr[k].coeff = p2.arr[j].coeff
            INCREMENT j
        END IF
        INCREMENT k
        INCREMENT p3.n
    END WHILE

    FOR i = i TO p1.n - 1
        SET p3.arr[k].exp = p1.arr[i].exp
        SET p3.arr[k].coeff = p1.arr[i].coeff
        INCREMENT k
        INCREMENT p3.n
    END FOR

    FOR j = j TO p2.n - 1
        SET p3.arr[k].exp = p2.arr[j].exp
        SET p3.arr[k].coeff = p2.arr[j].coeff
        INCREMENT k
        INCREMENT p3.n
    END FOR

    PRINT "SUM: "
    FOR i = 0 TO p3.n - 1
        PRINT p3.arr[i].coeff, "x^", p3.arr[i].exp
        IF i == p3.n - 1
            PRINT "\n"
        ELSE
            PRINT " + "
        END IF
    END FOR
END FUNCTION

#########################################################
QUEUE

STRUCT queue
    DECLARE size, rear, front: integers
    DECLARE arr[100]: array of integers
END STRUCT

FUNCTION isFull(q: pointer to queue) -> integer
    RETURN (q->rear == q->size - 1)

FUNCTION isEmpty(q: pointer to queue) -> integer
    RETURN (q->front == q->rear)

PROCEDURE enqueue(q: pointer to queue, n: integer)
    IF isFull(q) THEN
        PRINT "QUEUE IS FULL."
    ELSE
        q->arr[++(q->rear)] = n

PROCEDURE dequeue(q: pointer to queue)
    IF isEmpty(q) THEN
        PRINT "THE QUEUE IS EMPTY."
    ELSE
        PRINT q->arr[++(q->front)]

PROCEDURE display(q: pointer to queue)
    IF isEmpty(q) THEN
        PRINT "QUEUE IS EMPTY."
    ELSE
        FOR i = q->front + 1 TO q->rear
            PRINT q->arr[i]
        END FOR

PROCEDURE displayMenu()
    PRINT "------ MENU ------"
    PRINT "1. ENQUEUE"
    PRINT "2. DEQUEUE"
    PRINT "3. DISPLAY"
    PRINT "4. EXIT"
    PRINT "-------------------"

FUNCTION main()
    DECLARE q: queue
    SET q.front = q.rear = -1

    PRINT "ENTER THE SIZE OF QUEUE : "
    READ q.size

    DECLARE choice, n: integers

    WHILE choice != 4
        displayMenu()
        PRINT "ENTER CHOICE : "
        READ choice

        SWITCH choice
            CASE 1
                PRINT "ENTER THE ELEMENT : "
                READ n
                enqueue(&q, n)
            CASE 2
                dequeue(&q)
            CASE 3
                display(&q)
            CASE 4
                PRINT "EXITING."
            DEFAULT
                PRINT "WRONG CHOICE."
        END SWITCH
    END WHILE
END FUNCTION


##########################################################################




