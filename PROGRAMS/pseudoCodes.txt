POLYNOMIAL ADDITION

STRUCT term
    DECLARE INT exp, coeff
END STRUCT

STRUCT poly
    DECLARE INT n
    DECLARE arr[500]
END STRUCT

FUNCTION main()
    DECLARE poly p1, p2, p3
    DECLARE INT i, j, k
    SET p3.n = 0

    PRINT "ENTER THE NUMBER OF TERMS IN P1: "
    READ p1.n

    FOR i = 0 TO p1.n - 1
        PRINT "ENTER THE COEFF AS WELL AS EXP: "
        READ p1.arr[i].coeff, p1.arr[i].exp
    END FOR

    PRINT "ENTER THE NUMBER OF TERMS IN P2: "
    READ p2.n

    FOR i = 0 TO p2.n - 1
        PRINT "ENTER THE COEFF AS WELL AS EXP: "
        READ p2.arr[i].coeff, p2.arr[i].exp
    END FOR

    PRINT "FIRST: "
    FOR i = 0 TO p1.n - 1
        PRINT p1.arr[i].coeff, "x^", p1.arr[i].exp
        IF i == p1.n - 1
            PRINT " "
        ELSE
            PRINT " + "
        END IF
    END FOR

    PRINT "SECOND: "
    FOR i = 0 TO p2.n - 1
        PRINT p2.arr[i].coeff, "x^", p2.arr[i].exp
        IF i == p2.n - 1
            PRINT " "
        ELSE
            PRINT " + "
        END IF
    END FOR

    
    SET i = 0
    SET j = 0
    SET k = 0

    WHILE i < p1.n AND j < p2.n
        IF p1.arr[i].exp == p2.arr[j].exp
            SET p3.arr[k].exp = p1.arr[i].exp
            SET p3.arr[k].coeff = p1.arr[i].coeff + p2.arr[j].coeff
            INCREMENT i
            INCREMENT j
        ELSE IF p1.arr[i].exp < p2.arr[j].exp
            SET p3.arr[k].exp = p1.arr[i].exp
            SET p3.arr[k].coeff = p1.arr[i].coeff
            INCREMENT i
        ELSE
            SET p3.arr[k].exp = p2.arr[j].exp
            SET p3.arr[k].coeff = p2.arr[j].coeff
            INCREMENT j
        END IF
        INCREMENT k
        INCREMENT p3.n
    END WHILE

    FOR i = i TO p1.n - 1
        SET p3.arr[k].exp = p1.arr[i].exp
        SET p3.arr[k].coeff = p1.arr[i].coeff
        INCREMENT k
        INCREMENT p3.n
    END FOR

    FOR j = j TO p2.n - 1
        SET p3.arr[k].exp = p2.arr[j].exp
        SET p3.arr[k].coeff = p2.arr[j].coeff
        INCREMENT k
        INCREMENT p3.n
    END FOR

    PRINT "SUM: "
    FOR i = 0 TO p3.n - 1
        PRINT p3.arr[i].coeff, "x^", p3.arr[i].exp
        IF i == p3.n - 1
            PRINT "\n"
        ELSE
            PRINT " + "
        END IF
    END FOR
END FUNCTION

#########################################################
QUEUE

STRUCT queue
    DECLARE INT size, rear, front
    DECLARE arr[100]
END STRUCT

FUNCTION isFull(q: pointer to queue) -> integer
    RETURN (q->rear == q->size - 1)

FUNCTION isEmpty(q: pointer to queue) -> integer
    RETURN (q->front == q->rear)

PROCEDURE enqueue(q: pointer to queue, n: integer)
    IF isFull(q) THEN
        PRINT "QUEUE IS FULL."
    ELSE
        q->arr[++(q->rear)] = n

PROCEDURE dequeue(q: pointer to queue)
    IF isEmpty(q) THEN
        PRINT "THE QUEUE IS EMPTY."
    ELSE
        PRINT q->arr[++(q->front)]

PROCEDURE display(q: pointer to queue)
    IF isEmpty(q) THEN
        PRINT "QUEUE IS EMPTY."
    ELSE
        FOR i = q->front + 1 TO q->rear
            PRINT q->arr[i]
        END FOR

PROCEDURE displayMenu()
    PRINT "------ MENU ------"
    PRINT "1. ENQUEUE"
    PRINT "2. DEQUEUE"
    PRINT "3. DISPLAY"
    PRINT "4. EXIT"
    PRINT "-------------------"

FUNCTION main()
    DECLARE q: queue
    SET q.front = q.rear = -1

    PRINT "ENTER THE SIZE OF QUEUE : "
    READ q.size

    DECLARE choice, n: integers

    WHILE choice != 4
        displayMenu()
        PRINT "ENTER CHOICE : "
        READ choice

        SWITCH choice
            CASE 1
                PRINT "ENTER THE ELEMENT : "
                READ n
                enqueue(&q, n)
            CASE 2
                dequeue(&q)
            CASE 3
                display(&q)
            CASE 4
                PRINT "EXITING."
            DEFAULT
                PRINT "WRONG CHOICE."
        END SWITCH
    END WHILE
END FUNCTION


##########################################################################
BINARYSEARCH
FUNCTION binarySearch(A: array of integers, l: integer, h: integer, x: integer) -> integer
    IF l <= h THEN
        DECLARE INT mid
        SET mid = (l + h) / 2
        IF A[mid] == x THEN
            RETURN mid
        ELSE IF A[mid] > x THEN
            RETURN binarySearch(A, l, mid - 1, x)
        ELSE
            RETURN binarySearch(A, mid + 1, h, x)
        END IF
    END IF
    RETURN -1
END FUNCTION

FUNCTION main()
    DECLARE INT n, i, x
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE arr[n]
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    PRINT "ENTER THE ELEMENT TO BE SEARCHED: "
    READ x

    DECLARE INT index
    SET index = binarySearch(arr, 0, n - 1, x)
    IF index == -1 THEN
        PRINT "ELEMENT NOT FOUND."
    ELSE
        PRINT "THE POSITION IS: ", index
    END IF
END FUNCTION
########################################################################
LINEARSEARCH

PROCEDURE linearSearch(A: pointer to integer, n: integer, x: integer) -> integer
    FOR i = 0 TO n - 1
        IF A[i] == x THEN
            RETURN i
        END IF
    END FOR
    RETURN -1
END PROCEDURE

PROCEDURE main()
    DECLARE n, i, x: integers
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE arr[n]: array of integers
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    PRINT "ENTER THE ELEMENT TO BE SEARCHED: "
    READ x

    DECLARE index: integer
    SET index = linearSearch(arr, n, x)
    IF index == -1 THEN
        PRINT "ELEMENT NOT FOUND."
    ELSE
        PRINT "THE POSITION IS: ", index
    END IF
END PROCEDURE
##############################################################
REPEATED CHAR IN STRING
FUNCTION main()
    DECLARE ascii[129]: array of integers
    SET all elements of ascii to 0

    DECLARE str[1000]: array of characters
    PRINT "ENTER THE STRING: "
    READ str

    FOR i = 0 TO length of str - 1
        INCREMENT ascii[(int)str[i]]

    PRINT "REPEATED ELEMENTS ARE: "
    FOR i = 0 TO 129 - 1
        IF ascii[i] > 1 AND i != 32
            PRINT i AS CHARACTER, "-", ascii[i]
        END IF
    END FOR
END FUNCTION
#############################################################
SECOND LARGEST ELEMENT

FUNCTION swap(x: pointer to integer, y: pointer to integer)
    DECLARE temp: integer
    SET temp = *x
    *x = *y
    *y = temp
END FUNCTION

FUNCTION bubbleSort(A: pointer to integer, n: integer) -> integer
    DECLARE i, j, comp: integers
    FOR i = 0 TO 2
        SET comp = 0
        FOR j = 0 TO n - i - 1
            IF A[j] > A[j + 1] THEN
                CALL swap(&A[j], &A[j + 1])
                INCREMENT comp
            END IF
        END FOR
        IF comp == 0 THEN
            BREAK
        END IF
    END FOR
    RETURN A[n - 2]
END FUNCTION

FUNCTION main()
    DECLARE n, i, x, m: integers

    PRINT "ENTER THE NUMBER OF ELEMENTS: "
    READ n

    DECLARE arr[n]: array of integers
    PRINT "ENTER ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    PRINT "SECOND LARGEST ELEMENT IS: ", bubbleSort(arr, n)
END FUNCTION
#####################################################################
BUBBLE SORT

PROCEDURE swap(x: pointer to integer, y: pointer to integer)
    DECLARE temp: integer
    SET temp = *x
    *x = *y
    *y = temp
END PROCEDURE

PROCEDURE bubbleSort(A: pointer to integer, n: integer)
    DECLARE i, j, comp: integers
    FOR i = 0 TO n - 1
        SET comp = 0
        FOR j = 0 TO n - i - 1
            IF A[j] > A[j + 1] THEN
                CALL swap(&A[j], &A[j + 1])
                INCREMENT comp
            END IF
        END FOR
        IF comp == 0 THEN
            BREAK
        END IF
    END FOR
END PROCEDURE

PROCEDURE main()
    DECLARE n, i, x: integers
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE arr[n]: array of integers
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    CALL bubbleSort(arr, n)

    PRINT "THE SORTED ARRAY IS: "
    FOR i = 0 TO n - 1
        PRINT arr[i]
    END FOR
END PROCEDURE

###################################################################
INSERTION SORT

FUNCTION insertionSort(A: pointer to integer, n: integer)
    DECLARE i, j, key: integers
    FOR i = 1 TO n - 1
        SET key = A[i]
        SET j = i - 1

        WHILE j >= 0 AND A[j] > key
            SET A[j + 1] = A[j]
            DECREMENT j
        END WHILE

        SET A[j + 1] = key
    END FOR
END FUNCTION

FUNCTION main()
    DECLARE n, i: integers
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE arr[n]: array of integers
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    CALL insertionSort(arr, n)

    PRINT "THE SORTED ARRAY IS: "
    FOR i = 0 TO n - 1
        PRINT arr[i]
    END FOR
END FUNCTION

#################################################################
SELECTION SORT
PROCEDURE swap(x: pointer to integer, y: pointer to integer)
    DECLARE temp: integer
    SET temp = *x
    *x = *y
    *y = temp
END PROCEDURE

PROCEDURE selectionSort(A: pointer to integer, n: integer)
    DECLARE i, j, minIndex: integers
    FOR i = 0 TO n - 1
        SET minIndex = i
        FOR j = i + 1 TO n
            IF A[j] < A[minIndex] THEN
                SET minIndex = j
            END IF
        END FOR
        IF minIndex != i THEN
            CALL swap(&A[i], &A[minIndex])
        END IF
    END FOR
END PROCEDURE

PROCEDURE main()
    DECLARE n, i: integers
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE arr[n]: array of integers
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    CALL selectionSort(arr, n)

    PRINT "THE SORTED ARRAY IS: "
    FOR i = 0 TO n - 1
        PRINT arr[i]
    END FOR
END PROCEDURE

#################################################################
STACK

STACK

STRUCT stack
    DECLARE top, size: integers
    DECLARE arr[100]: array of integers
END STRUCT

FUNCTION isFull(st: pointer to stack) RETURNS integer
    RETURN (st->size == st->top + 1)
END FUNCTION

FUNCTION isEmpty(st: pointer to stack) RETURNS integer
    RETURN (st->top == -1)
END FUNCTION

PROCEDURE push(st: pointer to stack, ele: integer)
    IF isFull(st) THEN
        PRINT "STACK IS FULL."
    ELSE
        st->arr[++(st->top)] = ele
    END IF
END PROCEDURE

PROCEDURE pop(st: pointer to stack)
    IF isEmpty(st) THEN
        PRINT "STACK IS EMPTY."
    ELSE
        PRINT st->arr[(st->top)--]
    END IF
END PROCEDURE

PROCEDURE peek(st: pointer to stack)
    IF isEmpty(st) THEN
        PRINT "STACK IS EMPTY."
    ELSE
        PRINT st->arr[st->top]
    END IF
END PROCEDURE

PROCEDURE displayMenu()
    PRINT "\n------ MENU ------"
    PRINT "1. PUSH"
    PRINT "2. POP"
    PRINT "3. PEEK"
    PRINT "4. EXIT"
    PRINT "-------------------"
END PROCEDURE

PROCEDURE main()
    DECLARE st: stack
    st.top = -1

    PRINT "ENTER THE SIZE OF STACK: "
    READ st.size

    DECLARE choice, ele: integer

    WHILE choice != 4
        CALL displayMenu()
        PRINT "ENTER THE CHOICE: "
        READ choice

        SWITCH choice
            CASE 1
                PRINT "ENTER THE NUMBER: "
                READ ele
                CALL push(&st, ele)
            CASE 2
                CALL pop(&st)
            CASE 3
                CALL peek(&st)
            CASE 4
                PRINT "EXITING."
            DEFAULT
                PRINT "WRONG CHOICE."
        END SWITCH

        PRINT "\n"
    END WHILE
END PROCEDURE
##########################################################
SPARSE MATRIX REPRESENTATION
FUNCTION insertElements(m: integer, n: integer, A: 2D array of integers)
    PRINT "ENTER THE ELEMENTS"
    FOR i = 0 TO m - 1
        PRINT "ENTER THE ROW ", i + 1, ":"
        FOR j = 0 TO n - 1
            READ A[i][j]
        END FOR
    END FOR
END FUNCTION

FUNCTION display(m: integer, n: integer, A: 2D array of integers)
    PRINT "THE SPARSE MATRIX IS:"
    FOR i = 0 TO m - 1
        FOR j = 0 TO n - 1
            PRINT A[i][j], " "
        END FOR
        PRINT "\n"
    END FOR
END FUNCTION

FUNCTION convertToThreeTuple(r: integer, c: integer, A: 2D array of integers, C: 2D array of integers) -> integer
    DECLARE k: integer
    SET k = 1

    FOR i = 0 TO r - 1
        FOR j = 0 TO c - 1
            IF A[i][j] != 0 THEN
                SET C[k][0] = i
                SET C[k][1] = j
                SET C[k][2] = A[i][j]
                INCREMENT k
            END IF
        END FOR
    END FOR

    SET C[0][0] = r
    SET C[0][1] = c
    SET C[0][2] = k - 1

    RETURN k
END FUNCTION

FUNCTION main()
    DECLARE r, c: integers
    PRINT "ENTER THE ROW AND COLUMN OF MATRICES:"
    READ r, c

    DECLARE A[r][c], C[r * c][3]

    CALL insertElements(r, c, A)

    CALL display(r, c, A)

    DECLARE k1: integer
    SET k1 = convertToThreeTuple(r, c, A, C)

    CALL display(k1, 3, C)
END FUNCTION
#############################################################
MERGE SORT
FUNCTION merge(arr: array of integers, l: integer, m: integer, r: integer)
    DECLARE i, j, k: integers
    DECLARE n1, n2: integers

    SET n1 = m - l + 1
    SET n2 = r - m

    DECLARE L[n1]: array of integers
    DECLARE R[n2]: array of integers

    FOR i = 0 TO n1 - 1
        SET L[i] = arr[l + i]
    END FOR

    FOR j = 0 TO n2 - 1
        SET R[j] = arr[m + 1 + j]
    END FOR

    SET i = 0
    SET j = 0
    SET k = l

    WHILE i < n1 AND j < n2
        IF L[i] <= R[j] THEN
            SET arr[k] = L[i]
            INCREMENT i
        ELSE
            SET arr[k] = R[j]
            INCREMENT j
        END IF
        INCREMENT k
    END WHILE

    WHILE i < n1
        SET arr[k] = L[i]
        INCREMENT i
        INCREMENT k
    END WHILE

    WHILE j < n2
        SET arr[k] = R[j]
        INCREMENT j
        INCREMENT k
    END WHILE
END FUNCTION

FUNCTION mergeSort(arr: array of integers, l: integer, r: integer)
    IF l < r THEN
        DECLARE m: integer
        SET m = (l+r)/2 

        CALL mergeSort(arr, l, m)
        CALL mergeSort(arr, m + 1, r)

        CALL merge(arr, l, m, r)
    END IF
END FUNCTION

FUNCTION main()
    DECLARE n: integer
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE arr[n]: array of integers
    PRINT "ENTER THE ELEMENTS OF ARRAY: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    CALL mergeSort(arr, 0, n - 1)

    PRINT "SORTED ARRAY: "
    FOR i = 0 TO n - 1
        PRINT arr[i]
    END FOR
END FUNCTION


#################################################################
INFIX TO POSTFIX

FUNCTION isOperator(ch: character) -> integer
    IF ch is '+' OR ch is '-' OR ch is '*' OR ch is '/'
        RETURN 1
    ELSE
        RETURN 0

FUNCTION Precedence(ch: character) -> integer
    IF ch is '*' OR ch is '/'
        RETURN 2
    ELSE IF ch is '+' OR ch is '-'
        RETURN 1
    ELSE
        RETURN 0

PROCEDURE infixToPostfix(infix: array of characters, postfix: array of characters)
    DECLARE stack: array of characters
    DECLARE top: integer
    DECLARE i, j: integers

    top = -1
    j = 0

    FOR i = 0 TO length of infix - 1
        IF infix[i] is '('
            stack[++top] = infix[i]
        ELSE IF infix[i] is ')'
            WHILE stack[top] is not '('
                postfix[j++] = stack[top--]
            END WHILE
            top--
        ELSE IF isOperator(infix[i])
            WHILE top is not -1 AND Precedence(stack[top]) >= Precedence(infix[i])
                postfix[j++] = stack[top--]
            END WHILE
            stack[++top] = infix[i]
        ELSE
            postfix[j++] = infix[i]
        END IF
    END FOR

    WHILE top is not -1
        postfix[j++] = stack[top--]
    END WHILE

    postfix[j] = '\0'

END PROCEDURE

PROCEDURE main()
    DECLARE infix: array of characters
    DECLARE postfix: array of characters

    PRINT "Enter the infix expression: "
    READ infix

    CALL infixToPostfix(infix, postfix)

    PRINT "The postfix expression is: " + postfix

END PROCEDURE

##################################################################
POSTFIX EVALUATION










