POLYNOMIAL ADDITION

STRUCT term
    DECLARE INT exp, coeff
END STRUCT

STRUCT poly
    DECLARE INT n
    DECLARE term arr[500]
END STRUCT

PROCEDURE main()
    DECLARE poly p1, p2, p3
    DECLARE INT i, j, k
    SET p3.n = 0

    PRINT "ENTER THE NUMBER OF TERMS IN P1: "
    READ p1.n

    FOR i = 0 TO p1.n - 1
        PRINT "ENTER THE COEFF AS WELL AS EXP: "
        READ p1.arr[i].coeff, p1.arr[i].exp
    END FOR

    PRINT "ENTER THE NUMBER OF TERMS IN P2: "
    READ p2.n

    FOR i = 0 TO p2.n - 1
        PRINT "ENTER THE COEFF AS WELL AS EXP: "
        READ p2.arr[i].coeff, p2.arr[i].exp
    END FOR

    PRINT "FIRST: "
    FOR i = 0 TO p1.n - 1
        PRINT p1.arr[i].coeff, "x^", p1.arr[i].exp
        IF i == p1.n - 1
            PRINT " "
        ELSE
            PRINT " + "
        END IF
    END FOR

    PRINT "SECOND: "
    FOR i = 0 TO p2.n - 1
        PRINT p2.arr[i].coeff, "x^", p2.arr[i].exp
        IF i == p2.n - 1
            PRINT " "
        ELSE
            PRINT " + "
        END IF
    END FOR
    
    SET i = 0
    SET j = 0
    SET k = 0

    WHILE i < p1.n AND j < p2.n
        IF p1.arr[i].exp == p2.arr[j].exp
            SET p3.arr[k].exp = p1.arr[i].exp
            SET p3.arr[k].coeff = p1.arr[i].coeff + p2.arr[j].coeff
            INCREMENT i BY 1
            INCREMENT j BY 1
        ELSE IF p1.arr[i].exp < p2.arr[j].exp
            SET p3.arr[k].exp = p1.arr[i].exp
            SET p3.arr[k].coeff = p1.arr[i].coeff
            INCREMENT i By 1
        ELSE
            SET p3.arr[k].exp = p2.arr[j].exp
            SET p3.arr[k].coeff = p2.arr[j].coeff
            INCREMENT j BY 1
        END IF
        INCREMENT k BY 1
        INCREMENT p3.n BY 1
    END WHILE

    FOR i = i TO p1.n - 1
        SET p3.arr[k].exp = p1.arr[i].exp
        SET p3.arr[k].coeff = p1.arr[i].coeff
        INCREMENT k BY 1
        INCREMENT p3.n BY 1
    END FOR

    FOR j = j TO p2.n - 1
        SET p3.arr[k].exp = p2.arr[j].exp
        SET p3.arr[k].coeff = p2.arr[j].coeff
        INCREMENT k BY 1
        INCREMENT p3.n BY 1
    END FOR

    PRINT "SUM: "
    FOR i = 0 TO p3.n - 1
        PRINT p3.arr[i].coeff, "x^", p3.arr[i].exp
        IF i == p3.n - 1
            PRINT "\n"
        ELSE
            PRINT " + "
        END IF
    END FOR
END PROCEDURE

#########################################################
QUEUE

STRUCT queue
    DECLARE INT size, rear, front
    DECLARE arr[100]
END STRUCT

FUNCTION isFull(q: pointer to queue) -> integer
    RETURN (q->rear == q->size - 1)

FUNCTION isEmpty(q: pointer to queue) -> integer
    RETURN (q->front == q->rear)

PROCEDURE enqueue(q: pointer to queue, n: integer)
    IF isFull(q) THEN
        PRINT "QUEUE IS FULL."
    ELSE
        q->arr[++(q->rear)] = n

PROCEDURE dequeue(q: pointer to queue)
    IF isEmpty(q) THEN
        PRINT "THE QUEUE IS EMPTY."
    ELSE
        PRINT q->arr[++(q->front)]

PROCEDURE display(q: pointer to queue)
    IF isEmpty(q) THEN
        PRINT "QUEUE IS EMPTY."
    ELSE
        FOR i = q->front + 1 TO q->rear
            PRINT q->arr[i]
        END FOR

PROCEDURE displayMenu()
    PRINT "------ MENU ------"
    PRINT "1. ENQUEUE"
    PRINT "2. DEQUEUE"
    PRINT "3. DISPLAY"
    PRINT "4. EXIT"
    PRINT "-------------------"

FUNCTION main()
    DECLARE q: queue
    SET q.front = q.rear = -1

    PRINT "ENTER THE SIZE OF QUEUE : "
    READ q.size

    DECLARE choice, n: integers

    WHILE choice != 4
        displayMenu()
        PRINT "ENTER CHOICE : "
        READ choice

        SWITCH choice
            CASE 1
                PRINT "ENTER THE ELEMENT : "
                READ n
                enqueue(&q, n)
            CASE 2
                dequeue(&q)
            CASE 3
                display(&q)
            CASE 4
                PRINT "EXITING."
            DEFAULT
                PRINT "WRONG CHOICE."
        END SWITCH
    END WHILE
END FUNCTION



########################################################################
BINARY SEARCH

PROCEDURE binarySearch(int A[], INT l, INT h , INT x) 
    IF l <= h THEN
        DECLARE INT mid
        SET mid = (l + h) / 2

        IF A[mid] == x THEN
            RETURN mid
        ELSE IF A[mid] > x THEN
            RETURN binarySearch(A, l, mid - 1, x)
        ELSE
            RETURN binarySearch(A, mid + 1, h, x)
        END IF
    END IF

    RETURN -1
END PROCEDURE

PROCEDURE main()
    DECLARE INT n, i, x
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE INT arr[n]
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    PRINT "ENTER THE ELEMENT TO BE SEARCHED: "
    READ x

    DECLARE INT index
    SET index = binarySearch(arr, 0, n - 1, x)

    IF index == -1 THEN
        PRINT "ELEMENT NOT FOUND."
    ELSE
        PRINT "THE POSITION IS: ", index
    END IF
END PROCEDURE

########################################################################
LINEARSEARCH

PROCEDURE linearSearch(INT n , INT x, INT A[n])
    FOR i = 0 TO n - 1
        IF A[i] == x THEN
            RETURN i
        END IF
    END FOR
    RETURN -1
END PROCEDURE

PROCEDURE main()
    DECLARE INT n, i, x
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE INT arr[n]
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    PRINT "ENTER THE ELEMENT TO BE SEARCHED: "
    READ x

    DECLARE INT index
    SET index = linearSearch(arr, n, x)
    IF index == -1 THEN
        PRINT "ELEMENT NOT FOUND."
    ELSE
        PRINT "THE POSITION IS: ", index
    END IF
END PROCEDURE
##############################################################
REPEATED CHAR IN STRING
PROCEDURE main()
    DECLARE INT ascii[129]
    SET all elements of ascii to 0

    DECLARE CHAR str[1000]
    PRINT "ENTER THE STRING: "
    READ str

    FOR i = 0 TO (length of str - 1)
        INCREMENT ascii[(int)str[i]] BY 1

    PRINT "REPEATED ELEMENTS ARE: "
    FOR i = 0 TO 129
        IF ascii[i] > 1 AND i != 32
            PRINT i AS CHARACTER, "-", ascii[i]
        END IF
    END FOR
END PROCEDURE
#############################################################
SECOND LARGEST ELEMENT

PROCEDURE swap(INT *x , INT *y)
    DECLARE INT temp
    SET temp = *x
    *x = *y
    *y = temp
END PROCEDURE

PROCEDURE bubbleSort(INT n ,INT A[])
    DECLARE INT i, j, comp
    FOR i = 0 TO 2
        SET comp = 0
        FOR j = 0 TO n - i - 1
            IF A[j] > A[j + 1] THEN
                CALL swap(&A[j], &A[j + 1])
                INCREMENT comp BY 1
            END IF
        END FOR
        IF comp == 0 THEN
            BREAK
        END IF
    END FOR
    RETURN A[n - 2]
END PROCEDURE

PROCEDURE main()
    DECLARE INT n, i, x, m

    PRINT "ENTER THE NUMBER OF ELEMENTS: "
    READ n

    DECLARE INT arr[n]
    PRINT "ENTER ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    PRINT "SECOND LARGEST ELEMENT IS: ", bubbleSort(n, arr)
END PROCEDURE
#####################################################################
BUBBLE SORT

PROCEDURE swap(INT *x, INT *y)
    DECLARE INT temp
    SET temp = *x
    *x = *y
    *y = temp
END PROCEDURE

PROCEDURE bubbleSort(INT n , INT A[])
    DECLARE INT i, j, comp
    FOR i = 0 TO n - 1
        SET comp = 0
        FOR j = 0 TO n - i - 1
            IF A[j] > A[j + 1] THEN
                CALL swap(&A[j], &A[j + 1])
                INCREMENT comp BY 1
            END IF
        END FOR
        IF comp == 0 THEN
            BREAK
        END IF
    END FOR
END PROCEDURE

PROCEDURE main()
    DECLARE INT n, i, x
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE INT arr[n]
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    CALL bubbleSort(n , arr)

    PRINT "THE SORTED ARRAY IS: "
    FOR i = 0 TO n - 1
        PRINT arr[i]
    END FOR
END PROCEDURE

###################################################################
INSERTION SORT

PROCEDURE insertionSort(INT A[] , INT n)
    DECLARE INT i, j, key
    FOR i = 1 TO n - 1
        SET key = A[i]
        SET j = i - 1

        WHILE j >= 0 AND A[j] > key
            SET A[j + 1] = A[j]
            DECREMENT j BY 1
        END WHILE

        SET A[j + 1] = key
    END FOR
END PROCEDURE

PROCEDURE main()
    DECLARE INT n, i
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE INT arr[n]
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    CALL insertionSort(arr, n)
    
    PRINT "THE SORTED ARRAY IS: "
    FOR i = 0 TO n - 1
        PRINT arr[i]
    END FOR
END PROCEDURE

#################################################################
SELECTION SORT
PROCEDURE swap(INT *x , INT *y)
    DECLARE INT temp
    SET temp = *x
    *x = *y
    *y = temp
END PROCEDURE

PROCEDURE selectionSort(INT A[] , INT n)
    DECLARE INT i, j, minIndex
    FOR i = 0 TO n - 1
        SET minIndex = i
        FOR j = i + 1 TO n
            IF A[j] < A[minIndex] THEN
                SET minIndex = j
            END IF
        END FOR
        IF minIndex != i THEN
            CALL swap(&A[i], &A[minIndex])
        END IF
    END FOR
END PROCEDURE

PROCEDURE main()
    DECLARE INT n, i
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE INT arr[n]
    PRINT "ENTER THE ARRAY ELEMENTS: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    CALL selectionSort(arr, n)

    PRINT "THE SORTED ARRAY IS: "
    FOR i = 0 TO n - 1
        PRINT arr[i]
    END FOR
END PROCEDURE

#################################################################
STACK

STRUCT stack
    DECLARE top, size: integers
    DECLARE arr[100]: array of integers
END STRUCT

PROCEDURE isFull(st: pointer to stack) RETURNS integer
    RETURN (st->size == st->top + 1)
END PROCEDURE

PROCEDURE isEmpty(st: pointer to stack) RETURNS integer
    RETURN (st->top == -1)
END PROCEDURE

PROCEDURE push(st: pointer to stack, ele: integer)
    IF isFull(st) THEN
        PRINT "STACK IS FULL."
    ELSE
        st->arr[++(st->top)] = ele
    END IF
END PROCEDURE

PROCEDURE pop(st: pointer to stack)
    IF isEmpty(st) THEN
        PRINT "STACK IS EMPTY."
    ELSE
        PRINT st->arr[(st->top)--]
    END IF
END PROCEDURE

PROCEDURE peek(st: pointer to stack)
    IF isEmpty(st) THEN
        PRINT "STACK IS EMPTY."
    ELSE
        PRINT st->arr[st->top]
    END IF
END PROCEDURE

PROCEDURE displayMenu()
    PRINT "\n------ MENU ------"
    PRINT "1. PUSH"
    PRINT "2. POP"
    PRINT "3. PEEK"
    PRINT "4. EXIT"
    PRINT "-------------------"
END PROCEDURE

PROCEDURE main()
    DECLARE st: stack
    st.top = -1

    PRINT "ENTER THE SIZE OF STACK: "
    READ st.size

    DECLARE choice, ele: integer

    WHILE choice != 4
        CALL displayMenu()
        PRINT "ENTER THE CHOICE: "
        READ choice

        SWITCH choice
            CASE 1
                PRINT "ENTER THE NUMBER: "
                READ ele
                CALL push(&st, ele)
            CASE 2
                CALL pop(&st)
            CASE 3
                CALL peek(&st)
            CASE 4
                PRINT "EXITING."
            DEFAULT
                PRINT "WRONG CHOICE."
        END SWITCH

        PRINT "\n"
    END WHILE
END PROCEDURE
##########################################################
SPARSE MATRIX REPRESENTATION
PROCEDURE insertElements(m: integer, n: integer, A: 2D array of integers)
    PRINT "ENTER THE ELEMENTS"
    FOR i = 0 TO m - 1
        PRINT "ENTER THE ROW ", i + 1, ":"
        FOR j = 0 TO n - 1
            READ A[i][j]
        END FOR
    END FOR
END PROCEDURE

FUNCTION display(m: integer, n: integer, A: 2D array of integers)
    PRINT "THE SPARSE MATRIX IS:"
    FOR i = 0 TO m - 1
        FOR j = 0 TO n - 1
            PRINT A[i][j], " "
        END FOR
        PRINT "\n"
    END FOR
END FUNCTION

FUNCTION convertToThreeTuple(r: integer, c: integer, A: 2D array of integers, C: 2D array of integers) -> integer
    DECLARE k: integer
    SET k = 1

    FOR i = 0 TO r - 1
        FOR j = 0 TO c - 1
            IF A[i][j] != 0 THEN
                SET C[k][0] = i
                SET C[k][1] = j
                SET C[k][2] = A[i][j]
                INCREMENT k
            END IF
        END FOR
    END FOR

    SET C[0][0] = r
    SET C[0][1] = c
    SET C[0][2] = k - 1

    RETURN k
END FUNCTION

FUNCTION main()
    DECLARE r, c: integers
    PRINT "ENTER THE ROW AND COLUMN OF MATRICES:"
    READ r, c

    DECLARE A[r][c], C[r * c][3]

    CALL insertElements(r, c, A)

    CALL display(r, c, A)

    DECLARE k1: integer
    SET k1 = convertToThreeTuple(r, c, A, C)

    CALL display(k1, 3, C)
END FUNCTION
#############################################################
MERGE SORT
FUNCTION merge(arr: array of integers, l: integer, m: integer, r: integer)
    DECLARE i, j, k: integers
    DECLARE n1, n2: integers

    SET n1 = m - l + 1
    SET n2 = r - m

    DECLARE L[n1]: array of integers
    DECLARE R[n2]: array of integers

    FOR i = 0 TO n1 - 1
        SET L[i] = arr[l + i]
    END FOR

    FOR j = 0 TO n2 - 1
        SET R[j] = arr[m + 1 + j]
    END FOR

    SET i = 0
    SET j = 0
    SET k = l

    WHILE i < n1 AND j < n2
        IF L[i] <= R[j] THEN
            SET arr[k] = L[i]
            INCREMENT i
        ELSE
            SET arr[k] = R[j]
            INCREMENT j
        END IF
        INCREMENT k
    END WHILE

    WHILE i < n1
        SET arr[k] = L[i]
        INCREMENT i
        INCREMENT k
    END WHILE

    WHILE j < n2
        SET arr[k] = R[j]
        INCREMENT j
        INCREMENT k
    END WHILE
END FUNCTION

FUNCTION mergeSort(arr: array of integers, l: integer, r: integer)
    IF l < r THEN
        DECLARE m: integer
        SET m = (l+r)/2 

        CALL mergeSort(arr, l, m)
        CALL mergeSort(arr, m + 1, r)

        CALL merge(arr, l, m, r)
    END IF
END FUNCTION

FUNCTION main()
    DECLARE n: integer
    PRINT "ENTER THE SIZE OF ARRAY: "
    READ n

    DECLARE arr[n]: array of integers
    PRINT "ENTER THE ELEMENTS OF ARRAY: "
    FOR i = 0 TO n - 1
        READ arr[i]
    END FOR

    CALL mergeSort(arr, 0, n - 1)

    PRINT "SORTED ARRAY: "
    FOR i = 0 TO n - 1
        PRINT arr[i]
    END FOR
END FUNCTION


#################################################################
INFIX TO POSTFIX

FUNCTION isOperator(ch: character) -> integer
    IF ch is '+' OR ch is '-' OR ch is '*' OR ch is '/'
        RETURN 1
    ELSE
        RETURN 0

FUNCTION Precedence(ch: character) -> integer
    IF ch is '*' OR ch is '/'
        RETURN 2
    ELSE IF ch is '+' OR ch is '-'
        RETURN 1
    ELSE
        RETURN 0

PROCEDURE infixToPostfix(infix: array of characters, postfix: array of characters)
    DECLARE stack: array of characters
    DECLARE top: integer
    DECLARE i, j: integers

    top = -1
    j = 0

    FOR i = 0 TO length of infix - 1
        IF infix[i] is '('
            stack[++top] = infix[i]
        ELSE IF infix[i] is ')'
            WHILE stack[top] is not '('
                postfix[j++] = stack[top--]
            END WHILE
            top--
        ELSE IF isOperator(infix[i])
            WHILE top is not -1 AND Precedence(stack[top]) >= Precedence(infix[i])
                postfix[j++] = stack[top--]
            END WHILE
            stack[++top] = infix[i]
        ELSE
            postfix[j++] = infix[i]
        END IF
    END FOR

    WHILE top is not -1
        postfix[j++] = stack[top--]
    END WHILE

    postfix[j] = '\0'

END PROCEDURE

PROCEDURE main()
    DECLARE infix: array of characters
    DECLARE postfix: array of characters

    PRINT "Enter the infix expression: "
    READ infix

    CALL infixToPostfix(infix, postfix)

    PRINT "The postfix expression is: " + postfix

END PROCEDURE

##################################################################
POSTFIX EVALUATION

FUNCTION push(x: integer)
    stack[++top] = x

FUNCTION pop() -> integer
    RETURN stack[top--]

FUNCTION isOperator(ch: character) -> integer
    IF ch is '+' OR ch is '-' OR ch is '*' OR ch is '/'
        RETURN 1
    ELSE
        RETURN 0

FUNCTION Precedence(ch: character) -> integer
    IF ch is '*' OR ch is '/'
        RETURN 2
    ELSE IF ch is '+' OR ch is '-'
        RETURN 1
    ELSE
        RETURN 0

FUNCTION operation(a: integer, b: integer, ch: character) -> integer
    IF ch is '+'
        RETURN a + b
    ELSE IF ch is '-'
        RETURN a - b
    ELSE IF ch is '*'
        RETURN a * b
    ELSE IF ch is '/'
        RETURN a / b

FUNCTION postfixEval(postfix: array of characters) -> integer
    DECLARE res: integer
    FOR i = 0 TO length of postfix - 1
        IF isOperator(postfix[i]) is 0
            push(postfix[i] - '0')
        ELSE
            DECLARE a: integer = pop()
            DECLARE b: integer = pop()
            res = operation(b, a, postfix[i])
            push(res)
        END IF
    END FOR
    RETURN res

FUNCTION main()
    DECLARE postfix: array of characters
    PRINT "Enter the postfix expression: "
    READ postfix
    DECLARE res: integer = postfixEval(postfix)
    PRINT "The result is: " + res
    RETURN 0
END FUNCTION

##################################################################
CIRCULAR QUEUE

FUNCTION isFull()
    RETURN (front == rear + 1) OR (front == 0 AND rear == size - 1)
END FUNCTION

FUNCTION isEmpty()
    RETURN (front == -1)
END FUNCTION

FUNCTION enQueue(element)
    IF isFull() THEN
        PRINT "Queue is full!!"
    ELSE
        IF front == -1 THEN
            SET front = 0
        END IF
        SET rear = (rear + 1) % size
        SET items[rear] = element
        PRINT "Inserted -> " + element
    END IF
END FUNCTION

FUNCTION deQueue()
    DECLARE element
    IF isEmpty() THEN
        PRINT "Queue is empty!!"
        RETURN -1
    ELSE
        SET element = items[front]
        IF front == rear THEN
            SET front = -1
            SET rear = -1
        ELSE
            SET front = (front + 1) % size
        END IF
        PRINT "Deleted element -> " + element
        RETURN element
    END IF
END FUNCTION

FUNCTION display()
    DECLARE i
    IF isEmpty() THEN
        PRINT "Empty Queue"
    ELSE
        PRINT "Front -> " + front
        PRINT "Items -> "
        FOR i = front TO rear
            PRINT items[i] + " "
        END FOR
        PRINT "Rear -> " + rear
    END IF
END FUNCTION

FUNCTION menu()
    PRINT "Circular Queue:"
    PRINT "1. Insert"
    PRINT "2. Delete"
    PRINT "3. Display"
    PRINT "4. Exit"
END FUNCTION

FUNCTION main()
    DECLARE choice, element
    DO
        menu()
        PRINT "Enter your choice: "
        READ choice
        SWITCH choice
            CASE 1:
                PRINT "Enter the element to be inserted: "
                READ element
                enQueue(element)
                BREAK
            CASE 2:
                deQueue()
                BREAK
            CASE 3:
                display()
                BREAK
            CASE 4:
                PRINT "Exit"
                BREAK
            DEFAULT:
                PRINT "Invalid choice"
        END SWITCH
    WHILE choice != 4
    RETURN 0
END FUNCTION

#################################################################
PRIORITY QUEUE














