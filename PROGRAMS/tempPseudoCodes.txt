Linear Search
PROGRAM LINEARSEARCH

PROCEDURE MAIN
    INPUT size
    INPUT array of size
    INPUT key
    SET index = -1
    FOR i = 0 TO size
        IF array[i] = key
            SET index = i
            BREAK
        END IF
    END FOR
    IF index = -1
        PRINT "KEY NOT FOUND"
    ELSE
        PRINT "KEY FOUND AT INDEX ", index
    END IF
END PROCEDURE

END PROGRAM
Binary Search
PROGRAM BINARYSEARCH

PROCEDURE MAIN
    INPUT size
    INPUT array of size
    INPUT key
    SET index = -1
    SET low = 0
    SET high = size - 1
    WHILE low <= high
        SET mid = (low + high) / 2
        IF array[mid] = key
            SET index = mid
            BREAK
        ELSE IF array[mid] < key
            SET low = mid + 1
        ELSE
            SET high = mid - 1
        END IF
    END WHILE
    IF index = -1
        PRINT "KEY NOT FOUND"
    ELSE
        PRINT "KEY FOUND AT INDEX ", index
    END IF
END PROCEDURE

END PROGRAM
Linked List
PROGRAM LINKEDLIST

PROCEDURE ADDFRONT ACCEPTING HEAD
    CREATE NEWNODE
    INPUT NEWNODE->DATA
    SET NEWNODE->NEXT = HEAD
    SET HEAD = NEWNODE
    RETURN HEAD
END PROCEDURE

PROCEDURE ADDREAR ACCEPTING HEAD
    CREATE NEWNODE
    INPUT NEWNODE->DATA
    SET NEWNODE->NEXT = NULL
    IF HEAD = NULL
        SET HEAD = NEWNODE
    ELSE
        SET CURRENT = HEAD
        WHILE CURRENT->NEXT != NULL
            SET CURRENT = CURRENT->NEXT
        END WHILE
        SET CURRENT->NEXT = NEWNODE
    END IF
    RETURN HEAD
END PROCEDURE

PROCEDURE DELETEFRONT ACCEPTING HEAD
    IF HEAD = NULL
        PRINT "LIST IS EMPTY"
    ELSE
        SET TEMP = HEAD
        SET HEAD = HEAD->NEXT
        FREE TEMP
    END IF
    RETURN HEAD
END PROCEDURE

PROCEDURE DELETEREAR ACCEPTING HEAD
    IF HEAD = NULL
        PRINT "LIST IS EMPTY"
    ELSE
        SET CURRENT = HEAD
        IF CURRENT->NEXT = NULL
            SET HEAD = NULL
            FREE CURRENT
        ELSE
           WHILE CURRENT->NEXT != NULL
                IF CURRENT->NEXT->NEXT = NULL
                    SET TEMP = CURRENT->NEXT
                    SET CURRENT->NEXT = NULL
                    FREE TEMP
                ELSE
                    SET CURRENT = CURRENT->NEXT
                END IF
            END WHILE
        END IF
    END IF
    RETURN HEAD
END PROCEDURE

PROCEDURE DISPLAY ACCEPTING HEAD
    IF HEAD = NULL
        PRINT "LIST IS EMPTY"
    ELSE
        SET CURRENT = HEAD
        WHILE CURRENT != NULL
            PRINT CURRENT->DATA
            SET CURRENT = CURRENT->NEXT
        END WHILE
    END IF
END PROCEDURE

END PROGRAM
Queue using linked list

PROGRAM QUEUEUSINGLINKEDLIST

PROCEDURE ENQUEUE ACCEPTING HEAD
    CREATE NEWNODE
    INPUT NEWNODE->DATA
    SET NEWNODE->NEXT = NULL
    IF HEAD = NULL
        SET HEAD = NEWNODE
    ELSE
        SET CURRENT = HEAD
        WHILE CURRENT->NEXT != NULL
            SET CURRENT = CURRENT->NEXT
        END WHILE
        SET CURRENT->NEXT = NEWNODE
    END IF
    RETURN HEAD
END PROCEDURE

PROCEDURE DEQUEUE ACCEPTING HEAD
    IF HEAD = NULL
        PRINT "QUEUE IS EMPTY"
    ELSE
        SET TEMP = HEAD
        SET HEAD = HEAD->NEXT
        FREE TEMP
    END IF
    RETURN HEAD
END PROCEDURE

PROCEDURE DISPLAY ACCEPTING HEAD
    IF HEAD = NULL
        PRINT "QUEUE IS EMPTY"
    ELSE
        SET CURRENT = HEAD
        WHILE CURRENT != NULL
            PRINT CURRENT->DATA
            SET CURRENT = CURRENT->NEXT
        END WHILE
    END IF
END PROCEDURE

END PROGRAM
Stack using linked list
PROGRAM STACKUSINGLINKEDLIST

PROCEDURE PUSH ACCEPTING HEAD
    CREATE NEWNODE
    INPUT NEWNODE->DATA
    SET NEWNODE->NEXT = HEAD
    SET HEAD = NEWNODE
    RETURN HEAD
END PROCEDURE

PROCEDURE POP ACCEPTING HEAD
    IF HEAD = NULL
        PRINT "STACK IS EMPTY"
    ELSE
        SET TEMP = HEAD
        SET HEAD = HEAD->NEXT
        FREE TEMP
    END IF
    RETURN HEAD
END PROCEDURE

PROCEDURE DISPLAY ACCEPTING HEAD
    IF HEAD = NULL
        PRINT "STACK IS EMPTY"
    ELSE
        SET CURRENT = HEAD
        WHILE CURRENT != NULL
            PRINT CURRENT->DATA
            SET CURRENT = CURRENT->NEXT
        END WHILE
    END IF
END PROCEDURE

END PROGRAM